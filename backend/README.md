üìò FastAPI Backend ‚Äì Complete Project Documentation
1. Project Overview

This project is a FastAPI-based backend for an AI-powered Notepad application.
The system allows users to securely sign up and log in, create and manage notes using text or voice input, summarize content, generate categories using AI, and search notes by category.

The backend is designed using modern, scalable, and industry-standard architecture with clear separation of concerns.

2. Why FastAPI?

FastAPI was chosen as the backend framework because:

High performance (built on Starlette and Pydantic)

Asynchronous support for AI processing, file handling, and I/O tasks

Automatic API documentation using Swagger UI and ReDoc

Clean and maintainable structure

Well-suited for AI-driven applications

3. Backend Folder Structure

All backend logic is placed inside a main app/ folder to keep the project organized and modular.

app/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ database.py
‚îú‚îÄ‚îÄ logger.py
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ schemas/
‚îú‚îÄ‚îÄ crud/
‚îú‚îÄ‚îÄ services/
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îú‚îÄ‚îÄ vosk_model/
‚îú‚îÄ‚îÄ migrations/
‚îî‚îÄ‚îÄ __pycache__/

4. Purpose of Each Folder and File
4.1 main.py

Entry point of the FastAPI application

Initializes the FastAPI app

Includes routers

Configures middleware and logging

4.2 models/ Folder

Purpose: Database structure

Contains SQLAlchemy models

Defines tables such as Users, Notes, Categories

Handles relationships (including many-to-many)

Keeps database logic separate from API logic

Why used:
To maintain a clear ORM-based database design.

4.3 schemas/ Folder (Pydantic Schemas)

What is Pydantic?
Pydantic is used for data validation and serialization in FastAPI.

What are schemas?
Schemas define:

What data the API accepts (request)

What data the API returns (response)

Why schemas are used:

Ensures correct data types

Prevents invalid data

Improves API reliability

Separates database models from API responses

4.4 crud/ Folder

CRUD = Create, Read, Update, Delete

Purpose:

Handles all database operations

Keeps business logic separate from routes

Why used:

Clean architecture

Easier testing and maintenance

Reusable database logic

4.5 services/ Folder

Purpose:
Contains external and complex logic such as:

AI processing

Voice-to-text handling

Gemini API interaction

Why used:
To keep routes lightweight and focused only on request handling.

4.6 routers/ Folder

Purpose:
Defines API endpoints.

Each router handles a specific feature:

Authentication

Notes

Voice

Search

4.7 v1/ Folder (API Versioning)

What is API versioning?
Versioning allows multiple API versions to exist.

Why v1 is used:

Supports future updates (v2, v3)

Prevents breaking existing clients

Industry-standard backend practice

Example:

/api/v1/login
/api/v1/notes

5. __init__.py

Purpose:

Marks a folder as a Python package

Enables clean imports

Improves project modularity

Why used:
Required for large structured Python applications.

6. __pycache__

What it is:

Auto-generated Python folder

Stores compiled .pyc files

Why it exists:

Improves execution speed

Avoids recompiling Python files

Important:

Not manually created

Safe to delete

Not included in Git repositories

7. Logger (logger.py)

Purpose:

Logs API requests, errors, and system events

Helps in debugging and monitoring

Why used:

Production-ready backend requirement

Easier issue tracking

Better system observability

8. Database & Alembic Migrations
8.1 PostgreSQL Database

Used for persistent storage

Stores users, notes, categories, audio metadata

8.2 Alembic & migrations/ Folder

What is Alembic?
Alembic is a database migration tool for SQLAlchemy.

Why Alembic is used:

Version control for database schema

Safe schema updates

No manual SQL required

The migrations/ folder is auto-generated by Alembic.

9. Authentication ‚Äì Signup & Login

Why authentication is required:

Protect user data

Ensure user-specific notes

Secure API access

How it works:

User must sign up and log in first

Passwords are hashed

JWT tokens are used

Protected routes require authentication

10. Notepad (Notes System)

Core feature of the application

Users can:

Create notes

Update notes

Delete notes

View saved notes

Each note:

Belongs to a specific user

Can have summary and categories

Is stored securely in the database

11. Voice Recording & Voice-to-Text
11.1 Voice Recording Feature

Users can speak instead of typing

Voice is recorded via microphone

Maximum duration: 5 minutes

Recording is saved in PostgreSQL

Recording stops automatically after time limit

To continue speaking:

User must open the microphone again

Existing recording is updated

11.2 Vosk Model

What is Vosk?
Vosk is an offline speech-to-text model.

Why Vosk is used:

No internet dependency

Fast and lightweight

Supports real-time transcription

11.3 Vosk Model Folder

Stored inside backend

Includes downloaded English translation model

Ensures local processing

Improves reliability and performance

12. Real-Time Transcription

Spoken words are converted to text continuously

User can:

Speak

Type manually

Edit text

This text is then used for:

Summarization

Category generation

Saving as notes

13. AI Processing ‚Äì Gemini Model
13.1 What is Gemini?

Gemini is a Google Generative AI model used for natural language understanding.

13.2 Why Gemini is used?

High-quality text summarization

Accurate category generation

Context-aware understanding

13.3 Gemini API Key

Generated using Google AI Studio

Stored securely in environment variables

Used only in backend services

14. Summarization & Category Generation

Users can:

Summarize written or spoken text

Generate categories automatically

Both summary and categories are:

Generated using Gemini

Saved in the database

15. Database Relationships (Many-to-Many)

Why many-to-many?

One note can have multiple categories

One category can belong to multiple notes

This relationship allows:

Better organization

Flexible searching

Scalable categorization

16. Search by Category API

How it works:

User enters a category name

Backend searches related notes

All notes linked to that category are returned

Why implemented:

Improves usability

Allows structured note retrieval

17. Complete Backend Flow

User signs up or logs in

User opens Notepad

User types or records voice

Voice is converted to text (Vosk)

User can edit text manually

User requests summary & categories

Gemini generates results

Data is saved with relationships

User can search notes by category

18. Conclusion

This FastAPI backend is:

üîê Secure

‚ö° High-performance

üß† AI-powered

üß± Scalable and maintainable

üì¶ Industry-standard

It combines authentication, voice processing, AI intelligence, database design, and clean architecture into a complete production-ready system.